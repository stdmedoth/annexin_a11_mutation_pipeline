# Conformational and Energetic Analysis Guide

This guide describes methods to analyze the conformational and energetic profiles
of protein ensembles generated by BioEmu, with focus on comparing wild-type (WT)
and mutant variants for binder design.

## Table of Contents

1. [Structural Metrics](#1-structural-metrics)
2. [Principal Component Analysis](#2-principal-component-analysis)
3. [Free Energy Landscape](#3-free-energy-landscape)
4. [Contact Analysis](#4-contact-analysis)
5. [Clustering Analysis](#5-clustering-analysis)
6. [Dynamic Network Analysis](#6-dynamic-network-analysis)
7. [Binder Design Applications](#7-binder-design-applications)

---

## 1. Structural Metrics

### 1.1 RMSD (Root Mean Square Deviation)

Measures the average distance between atoms after optimal superposition.

```python
import mdtraj as md

# Load trajectories
wt_traj = md.load("wt/aligned_ensemble.pdb")
mut_traj = md.load("mutant/aligned_ensemble.pdb")

# RMSD to first frame
rmsd_wt = md.rmsd(wt_traj, wt_traj, frame=0) * 10  # nm to Å
rmsd_mut = md.rmsd(mut_traj, mut_traj, frame=0) * 10

print(f"WT RMSD: {rmsd_wt.mean():.2f} ± {rmsd_wt.std():.2f} Å")
print(f"Mutant RMSD: {rmsd_mut.mean():.2f} ± {rmsd_mut.std():.2f} Å")
```

**Interpretation:**
- Higher RMSD → More structural variability
- Mutant with higher RMSD may indicate destabilization

### 1.2 RMSF (Root Mean Square Fluctuation)

Per-residue flexibility measure.

```python
# Calculate RMSF
rmsf_wt = md.rmsf(wt_traj, wt_traj, frame=0) * 10
rmsf_mut = md.rmsf(mut_traj, mut_traj, frame=0) * 10

# Compare at mutation site
mutation_position = 123  # Example
delta_rmsf = rmsf_mut[mutation_position-1] - rmsf_wt[mutation_position-1]
print(f"ΔRMSF at mutation site: {delta_rmsf:+.2f} Å")
```

**Interpretation:**
- Higher RMSF → More flexible region
- Increased flexibility near mutation → Potential functional impact

### 1.3 Radius of Gyration

Measure of overall compactness.

```python
rg_wt = md.compute_rg(wt_traj) * 10  # nm to Å
rg_mut = md.compute_rg(mut_traj) * 10

print(f"WT Rg: {rg_wt.mean():.2f} ± {rg_wt.std():.2f} Å")
print(f"Mutant Rg: {rg_mut.mean():.2f} ± {rg_mut.std():.2f} Å")
```

**Interpretation:**
- Increased Rg → More expanded/unfolded conformations
- Significant change may indicate structural destabilization

---

## 2. Principal Component Analysis

PCA identifies the dominant modes of conformational variability.

```python
from sklearn.decomposition import PCA
import numpy as np

# Prepare data (flatten coordinates)
wt_coords = wt_traj.xyz.reshape(wt_traj.n_frames, -1)
mut_coords = mut_traj.xyz.reshape(mut_traj.n_frames, -1)

# Fit PCA on combined data
combined = np.vstack([wt_coords, mut_coords])
pca = PCA(n_components=10)
projections = pca.fit_transform(combined)

# Split back
wt_proj = projections[:wt_traj.n_frames]
mut_proj = projections[wt_traj.n_frames:]

# Explained variance
print("Variance explained by first 3 PCs:", pca.explained_variance_ratio_[:3].sum())
```

### 2.1 PC Projection Comparison

```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(10, 8))
ax.scatter(wt_proj[:, 0], wt_proj[:, 1], alpha=0.5, label='WT', c='blue')
ax.scatter(mut_proj[:, 0], mut_proj[:, 1], alpha=0.5, label='Mutant', c='red')
ax.set_xlabel('PC1')
ax.set_ylabel('PC2')
ax.legend()
plt.title('Conformational Space Comparison')
plt.savefig('pca_comparison.png', dpi=150)
```

**Interpretation:**
- Overlapping distributions → Similar conformational space
- Separated distributions → Mutation shifts conformational ensemble
- New regions explored by mutant → Novel conformational states

---

## 3. Free Energy Landscape

Convert population density to free energy.

```python
def compute_free_energy(x, y, bins=50, temperature=300):
    """Compute 2D free energy landscape."""
    kB = 0.001987  # kcal/(mol·K)
    
    hist, xedges, yedges = np.histogram2d(x, y, bins=bins)
    prob = hist / hist.sum()
    prob[prob == 0] = 1e-10  # Avoid log(0)
    
    free_energy = -kB * temperature * np.log(prob)
    free_energy -= free_energy.min()  # Set minimum to zero
    
    return free_energy, xedges, yedges

# Compute for WT
fel_wt, x_edges, y_edges = compute_free_energy(wt_proj[:, 0], wt_proj[:, 1])

# Compute for mutant
fel_mut, _, _ = compute_free_energy(mut_proj[:, 0], mut_proj[:, 1])
```

### 3.1 Visualize Energy Landscape

```python
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# WT landscape
im1 = axes[0].contourf(fel_wt.T, levels=20, cmap='RdYlBu_r')
axes[0].set_title('WT Free Energy Landscape')
plt.colorbar(im1, ax=axes[0], label='ΔG (kcal/mol)')

# Mutant landscape
im2 = axes[1].contourf(fel_mut.T, levels=20, cmap='RdYlBu_r')
axes[1].set_title('Mutant Free Energy Landscape')
plt.colorbar(im2, ax=axes[1], label='ΔG (kcal/mol)')

plt.savefig('free_energy_landscape.png', dpi=150)
```

**Interpretation:**
- Deep basins → Stable conformational states
- Multiple basins → Conformational heterogeneity
- Basin shifts → Mutation alters energy landscape
- Barrier heights → Kinetic accessibility

---

## 4. Contact Analysis

### 4.1 Contact Maps

```python
def compute_contact_map(traj, cutoff=0.8):  # 8 Å in nm
    """Compute average contact map."""
    pairs = []
    for i in range(traj.n_residues):
        for j in range(i+4, traj.n_residues):  # Skip neighbors
            pairs.append((i, j))
    
    distances = md.compute_distances(traj, pairs)
    contacts = (distances < cutoff).astype(float)
    
    contact_map = np.zeros((traj.n_residues, traj.n_residues))
    for idx, (i, j) in enumerate(pairs):
        contact_map[i, j] = contacts[:, idx].mean()
        contact_map[j, i] = contact_map[i, j]
    
    return contact_map

contact_wt = compute_contact_map(wt_traj)
contact_mut = compute_contact_map(mut_traj)
```

### 4.2 Differential Contact Map

```python
diff_contacts = contact_mut - contact_wt

plt.figure(figsize=(10, 8))
plt.imshow(diff_contacts, cmap='RdBu_r', vmin=-0.5, vmax=0.5)
plt.colorbar(label='ΔContact Probability')
plt.xlabel('Residue')
plt.ylabel('Residue')
plt.title('Differential Contact Map (Mutant - WT)')
plt.savefig('differential_contacts.png', dpi=150)
```

**Interpretation:**
- Red regions → Increased contacts in mutant
- Blue regions → Lost contacts in mutant
- Changes near mutation site → Local structural effects
- Distal changes → Allosteric effects

---

## 5. Clustering Analysis

Group similar conformations to identify representative structures.

```python
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

# Cluster combined ensemble
n_clusters = 5
kmeans = KMeans(n_clusters=n_clusters, random_state=42)
labels = kmeans.fit_predict(projections[:, :3])

# Analyze cluster populations
wt_labels = labels[:wt_traj.n_frames]
mut_labels = labels[wt_traj.n_frames:]

for i in range(n_clusters):
    wt_count = (wt_labels == i).sum()
    mut_count = (mut_labels == i).sum()
    print(f"Cluster {i}: WT={wt_count}, Mutant={mut_count}")
```

### 5.1 Extract Representative Structures

```python
# Find frames closest to cluster centers
from scipy.spatial.distance import cdist

for i in range(n_clusters):
    cluster_frames = np.where(wt_labels == i)[0]
    if len(cluster_frames) > 0:
        cluster_coords = wt_proj[cluster_frames, :3]
        distances = cdist([kmeans.cluster_centers_[i]], cluster_coords)[0]
        representative = cluster_frames[np.argmin(distances)]
        wt_traj[representative].save(f'representative_cluster{i}.pdb')
```

---

## 6. Dynamic Network Analysis

### 6.1 Correlation Networks

```python
def compute_correlation_matrix(traj):
    """Compute residue motion correlation matrix."""
    # Calculate fluctuations from mean
    mean_coords = traj.xyz.mean(axis=0)
    fluctuations = traj.xyz - mean_coords
    
    # Get CA atoms
    ca_indices = traj.topology.select('name CA')
    ca_fluct = fluctuations[:, ca_indices, :]
    
    n_residues = len(ca_indices)
    n_frames = traj.n_frames
    
    # Compute correlation
    corr_matrix = np.zeros((n_residues, n_residues))
    for i in range(n_residues):
        for j in range(n_residues):
            num = np.sum(ca_fluct[:, i, :] * ca_fluct[:, j, :])
            denom = np.sqrt(np.sum(ca_fluct[:, i, :]**2) * 
                          np.sum(ca_fluct[:, j, :]**2))
            corr_matrix[i, j] = num / denom if denom > 0 else 0
    
    return corr_matrix

corr_wt = compute_correlation_matrix(wt_traj)
corr_mut = compute_correlation_matrix(mut_traj)
```

### 6.2 Community Detection

```python
import networkx as nx

def create_network(corr_matrix, threshold=0.5):
    """Create network from correlation matrix."""
    G = nx.Graph()
    n = corr_matrix.shape[0]
    
    for i in range(n):
        G.add_node(i)
        for j in range(i+1, n):
            if abs(corr_matrix[i, j]) > threshold:
                G.add_edge(i, j, weight=abs(corr_matrix[i, j]))
    
    return G

G_wt = create_network(corr_wt)
G_mut = create_network(corr_mut)

# Detect communities
from networkx.algorithms import community
communities_wt = list(community.greedy_modularity_communities(G_wt))
communities_mut = list(community.greedy_modularity_communities(G_mut))
```

---

## 7. Binder Design Applications

### 7.1 Identifying Target Conformations

For binder design to prevent mutation effects:

1. **Find mutation-specific conformations:**
```python
# Conformations unique to mutant (potential targets for binders)
mut_only_mask = np.zeros(mut_traj.n_frames, dtype=bool)
for i in range(mut_traj.n_frames):
    dist_to_wt = cdist([mut_proj[i, :3]], wt_proj[:, :3]).min()
    if dist_to_wt > threshold:  # Far from WT ensemble
        mut_only_mask[i] = True

mutation_specific = mut_traj[mut_only_mask]
mutation_specific.save('mutation_specific_conformations.pdb')
```

2. **Analyze mutation site accessibility:**
```python
# SASA at mutation site
sasa_wt = md.shrake_rupley(wt_traj, mode='residue')
sasa_mut = md.shrake_rupley(mut_traj, mode='residue')

mutation_residue = 122  # 0-indexed
print(f"WT SASA at mutation: {sasa_wt[:, mutation_residue].mean():.2f} nm²")
print(f"Mutant SASA at mutation: {sasa_mut[:, mutation_residue].mean():.2f} nm²")
```

### 7.2 Binder Binding Site Analysis

```python
# Identify regions with consistent accessibility for binding
def find_stable_binding_sites(traj, min_sasa=0.5, consistency=0.8):
    """Find residues consistently accessible."""
    sasa = md.shrake_rupley(traj, mode='residue')
    
    accessible_fraction = (sasa > min_sasa).mean(axis=0)
    stable_sites = np.where(accessible_fraction > consistency)[0]
    
    return stable_sites

wt_sites = find_stable_binding_sites(wt_traj)
mut_sites = find_stable_binding_sites(mut_traj)

# Sites accessible in mutant but not WT (potential binder targets)
mutation_exposed = set(mut_sites) - set(wt_sites)
print(f"Mutation-exposed sites: {mutation_exposed}")
```

### 7.3 Druggability Assessment

```python
# Identify pocket-like regions near mutation
from scipy.spatial import ConvexHull

def estimate_pocket_volume(coords, residue_indices):
    """Estimate pocket volume from residue coordinates."""
    pocket_coords = coords[residue_indices]
    if len(pocket_coords) >= 4:
        hull = ConvexHull(pocket_coords)
        return hull.volume
    return 0

# Define region around mutation site
mutation_pos = 122
nearby = [i for i in range(max(0, mutation_pos-5), 
                           min(mut_traj.n_residues, mutation_pos+6))]
```

---

## Summary Recommendations

For analyzing mutation effects and designing binders:

1. **Start with basic metrics** (RMSD, RMSF, Rg) to quantify overall changes

2. **Use PCA** to visualize conformational space and identify mutation-specific states

3. **Compute free energy landscapes** to understand thermodynamic effects

4. **Analyze contacts** to find structural changes near and far from mutation

5. **Cluster conformations** to get representative structures for binder design

6. **Assess accessibility** to identify potential binding epitopes

7. **Compare dynamics** to understand allosteric effects

Remember: The goal is to find conformations or regions that:
- Are specific to the mutant
- Are accessible for binder binding
- Would stabilize the WT-like state if bound
